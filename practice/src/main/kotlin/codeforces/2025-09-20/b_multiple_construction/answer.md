# B. 다중 구성 (Multiple Construction) — 해설 (DSU 기반)

문제: 길이 `2n` 배열을 구성하라. 각 정수 `1..n`은 정확히 두 번 나타나고, 각 정수 `x`에 대해 두 등장의 위치 차 `|q_x - p_x|`는 `x`의 배수여야 한다. 문제는 항상 해가 존재함이 보장된다.

---

## 핵심 아이디어 — 빈 자리(next-free)를 빠르게 관리하며 배치

가장 제약이 큰 숫자(즉 큰 숫자)부터 채워 나가면 되는 직관을 기반으로, **빈 자리들을 효율적으로 찾고 건너뛰는** DSU(또는 next-pointer) 자료구조를 사용한다.
`find(i)`는 `i` 이상에서 첫 번째 비어 있는 인덱스를 반환하도록 하고, 채운 인덱스는 `remove(i)`로 목록에서 제거(=다음으로 연결)한다. 이로써 각 인덱스는 한 번만 방문/제거되어 효율적이다.

---

## 알고리즘 (요약)

1. `N = 2 * n`. `ans[0..N-1] = 0`으로 초기화(0 = 빈칸).
2. `parent[0..N]` 초기화: `parent[i] = i` (`parent[N]`은 sentinel).

    * `find(i)`: `i` 이상에서 첫 번째 빈칸 인덱스를 반환(경로 압축).
    * `remove(i)`: `i`를 비어 있는 목록에서 제거(실제 구현에서는 `parent[i] = find(i+1)`).
3. `for x in n downTo 1`:

    * `p = find(0)`부터 시작해 가능한 빈칸 `p`들을 순회(`p = find(p+1)`로 다음 빈칸으로 이동).
    * 각 `p`에 대해 `qPos = p + k * x` (k = 1,2,...)로 후보를 만들고 `q = find(qPos)`를 호출.
    * 만약 `q == qPos`(즉 `qPos`가 비어있다면)과 `ans[p] == 0`이면 `ans[p] = ans[q] = x`로 배치하고 `remove(p)`, `remove(q)` 수행. 그 다음 `x` 처리 종료.
4. 모든 `x`가 배치되면 `ans` 출력.

---

## 유효성(왜 항상 배치 가능?)

* 어떤 `x`를 처리할 때 남아 있는 빈칸의 수는 \*\*정확히 `2*x`\*\*이다. (큰 수부터 배치했으므로)
* 빈칸들을 `x`개의 잔류 클래스(`index mod x` = `0..x-1`)로 나누면 `2*x`개의 빈칸을 `x`개의 바구니에 나누는 셈이므로(비둘기집 원리) 어떤 클래스에는 적어도 2개의 빈칸이 존재한다.
* 같은 모듈 클래스를 갖는 두 인덱스 `p`와 `q`는 차가 `k * x` (k≥1) 이므로 `x`의 요구조건을 만족한다.
* DSU 방식은 이런 실제 존재하는 `p,q`를 찾아내도록 설계되어 있으므로 항상 유효한 쌍을 찾는다. (문제의 “항상 해가 존재” 보장이 이 탐색 실패를 막음)

---

## 시간복잡도(실용적 분석)

* `find`/`remove`는 경로 압축을 사용하면 거의 상수(역함수 α(N)) 시간.
* 바깥 루프는 `n`번. 각 빈칸은 한 번만 `find`로 방문되고 한 번만 `remove`되므로 전체적으로 `find` 호출은 O(N α(N)) 수준.
* 각 `p`에서 `k`를 증가시키며 `qPos = p + k*x`를 검사하는 비용은 이론적으로 $\sum_{x=1}^{n} O(N/x)$ 형태이지만, `find(qPos)`로 빠르게 건너뛰므로 실제 성능은 매우 좋음.
* 실전에는 **거의 선형**에 가깝게 동작하므로 `sum n ≤ 2·10^5` 제약에서 안전.

---

## 구현 포인트 / 주의사항

* `parent` 배열 크기는 `N + 1`로 만들고 `parent[N] = N`(sentinel)로 둔다.
* `find(i)`에서 `i`가 `N`이면 `N`을 반환하도록 처리(범위 검사).
* `remove(i)`는 `parent[i] = find(i + 1)`로 구현(경로 압축을 이용한 union).
* 문제 보장에 따라 `placed`가 항상 `true`가 되어야 하므로 실패 분기는 사실 발생하지 않음(안전장치로 `-1` 반환해도 됨).

---

## 비교: DSU 방식 vs 단순 그리디 (rightmost p2 선택)

* **단순 그리디(오른쪽 p2 고정, p1 = p2 - k\*x)**:

    * 구현이 매우 간단함. `lastFree` 포인터를 유지하면 빠름.
    * 실전에서 잘 작동하고 빠름(간단 최적화로 O(n log n) 수준).
    * 그러나 “빈칸 건너뛰기” 처리가 약하면 상수요소가 커질 수 있음.
* **DSU 방식**:

    * `find`/`remove`로 빈칸 관리를 체계화 → 각 인덱스는 한 번만 방문/제거.
    * 구현은 조금 더 복잡하지만 **이론적 안정성**과 **실전 성능** 모두 우수.
    * 범용적으로 다음 사용 가능한 위치를 찾는 문제에 강력.

    
---

## 예시(작은 n에 대한 단계별 시뮬레이션)

예: `n = 3`, `N = 6`

* 초기 `ans = [0,0,0,0,0,0]`, `parent = [0,1,2,3,4,5,6]`
* `x = 3`: `p = find(0) = 0`. 가능한 `qPos = 0 + 1*3 = 3`. `q = find(3) = 3` → 배치 `ans[0]=ans[3]=3`. `remove(0)`, `remove(3)`.
* `x = 2`: 다음 `p = find(0) = 1` (0는 제거됨). 가능한 `qPos = 1 + 1*2 = 3` → `find(3)`은 4로 간다(3 제거됨), 4 비어있으면 `qPos != find(qPos)`이므로 k=2: `qPos = 1 + 2*2 = 5` → `find(5)=5` → 배치 `ans[1]=ans[5]=2`.
* `x = 1`: `p = find(0) = 2`. `qPos = 2 + 1*1 = 3` → `find(3)` → 4, 안맞 → k=2: `qPos = 2 + 2*1 = 4` → `find(4)=4` → 배치 `ans[2]=ans[4]=1`.
* 최종 `ans = [3,2,1,3,1,2]` (모두 조건 만족).

---

