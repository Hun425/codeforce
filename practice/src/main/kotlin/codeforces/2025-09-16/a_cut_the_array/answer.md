# A. Cut the Array 문제 풀이 해설

이 문서에서는 "A. Cut the Array" 문제의 해결 과정과 핵심 아이디어를 설명합니다.

## 1. 문제 분석

문제의 목표는 주어진 배열 `a`를 세 개의 비어있지 않은 부분으로 나누는 것입니다. 나누는 기준은 두 개의 인덱스 `l`과 `r`이며, 이로 인해 배열은 다음과 같이 세 부분으로 나뉩니다.

1.  `a[1...l]` (접두사)
2.  `a[l+1...r]` (중앙 부분)
3.  `a[r+1...n]` (접미사)

이때, 각 부분의 합을 3으로 나눈 나머지(s1, s2, s3)가 **모두 같거나** 또는 **모두 달라야** 합니다. 이 조건을 만족하는 `l`과 `r`을 찾는 것이 문제입니다.

## 2. 핵심 아이디어

문제의 제약 조건을 살펴보면, 배열의 크기 `n`이 최대 40으로 매우 작습니다. 이는 복잡한 알고리즘 없이도 시간 안에 문제를 해결할 수 있음을 시사합니다.

따라서, 가능한 모든 `l`과 `r`의 조합을 시도해보는 **완전 탐색(Brute-force)** 접근법을 사용할 수 있습니다.

- `l`은 `1`부터 `n-2`까지 가능합니다.
- `r`은 `l+1`부터 `n-1`까지 가능합니다.

이 모든 조합을 순회하며 문제의 조건을 만족하는지 확인하면 됩니다.

## 3. 알고리즘 설계 및 최적화

완전 탐색을 위한 기본 알고리즘은 다음과 같습니다.

```
for l from 1 to n-2:
  for r from l+1 to n-1:
    // 1. 세 부분의 합 계산
    // 2. 각 합을 3으로 나눈 나머지(s1, s2, s3) 계산
    // 3. s1, s2, s3가 모두 같거나 모두 다른지 확인
    // 4. 조건을 만족하면 (l, r)을 반환하고 종료
```

### 효율성 개선: 누적 합 (Prefix Sum)

위 알고리즘에서 매번 `l`과 `r`이 바뀔 때마다 세 부분의 합을 처음부터 다시 계산하는 것은 비효율적입니다. 이 계산 과정을 최적화하기 위해 **누적 합(Prefix Sum)** 기법을 사용합니다.

1.  먼저, 원래 배열 `a`의 누적 합 배열 `prefixSum`을 만듭니다. `prefixSum[i]`는 `a[1]`부터 `a[i]`까지의 합을 저장합니다. 이 과정은 시간 복잡도 O(n)이 걸립니다.

2.  누적 합 배열을 이용하면, 특정 구간의 합을 O(1) 시간 복잡도로 매우 빠르게 계산할 수 있습니다.
    - **첫 번째 부분의 합:** `prefixSum[l]`
    - **두 번째 부분의 합:** `prefixSum[r] - prefixSum[l]`
    - **세 번째 부분의 합:** `prefixSum[n] - prefixSum[r]`

3.  이처럼 누적 합을 사용하면, `l`과 `r`을 순회하는 이중 반복문 내에서 합 계산이 O(1)에 이루어지므로, 전체 시간 복잡도는 O(n²)이 됩니다. `n`이 최대 40이므로 이 방법은 충분히 빠릅니다.

## 4. 최종 구현

`Solution.kt`의 `solve` 함수는 위에서 설명한 누적 합을 이용한 완전 탐색 알고리즘을 구현한 것입니다.

- 먼저 누적 합 배열 `prefixSum`을 계산합니다.
- 이중 for 문을 통해 모든 유효한 `(l, r)` 쌍을 탐색합니다.
- 각 쌍에 대해 O(1)에 세 부분의 합을 구하고, 3으로 나눈 나머지를 비교합니다.
- 조건을 만족하는 첫 번째 `(l, r)` 쌍을 찾으면 즉시 반환합니다.
- 만약 모든 쌍을 탐색해도 조건을 만족하는 경우가 없으면, `(0, 0)`을 반환합니다.
