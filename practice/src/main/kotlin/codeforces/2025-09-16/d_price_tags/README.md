# D. Price Tags

시간 제한: 테스트 케이스당 2초
메모리 제한: 테스트 케이스당 256 메가바이트

## 문제 설명

당신이 상점의 주인이라고 상상해보세요. 새로운 시즌이 시작되기 전에, 재고로 남은 상품들을 정리하기로 결정했고, 따라서 전체 세일을 진행하기로 했습니다.

상점에는 n개의 서로 다른 상품이 있습니다: i번째 상품의 가격은 ci 코인입니다. 각 상품에는 해당 가격 ci가 적힌 가격표가 붙어있습니다. 당신은 "모든 가격을 x배로 나눴습니다"라는 형식으로 세일을 진행하기로 했습니다. 공식적으로, 이는 공통 계수 x를 선택하고, 세일 기간 동안 i번째 상품의 가격이 ⌈ci/x⌉ 코인이 된다는 의미입니다 (여기서 ⌈y⌉는 올림을 의미합니다).

고객들의 혼란을 피하기 위해, 모든 상품에 새로운 가격이 적힌 새 가격표를 붙여야 하는데, 새 가격표를 인쇄하는 것은 비용이 많이 듭니다. 구체적으로, 각 인쇄된 가격표는 y 코인이 듭니다.

따라서 당신은 기발한 아이디어를 생각했습니다 — 기존 가격표를 다른 상품에 다시 붙이면 어떨까요? 그러면 해당하는 가격표가 없는 상품들에만 새 가격표를 인쇄하면 됩니다.

마지막 질문이 하나 남았습니다: 가격을 얼마나 낮춰야 할까요, 즉 x를 어떻게 선택해야 할까요? 계수 x는 1보다 큰 정수여야 하며, 총 수익이 최대가 되도록 해야 합니다. 총 수익은 상품들의 총 가치에서 인쇄된 가격표의 비용을 뺀 값입니다.

최대 가능한 총 수익을 구하세요.

## 입력

첫 번째 줄에는 테스트 케이스의 수 t (1 ≤ t ≤ 10)가 주어집니다.

각 테스트 케이스의 첫 번째 줄에는 두 정수 n과 y (1 ≤ n ≤ 2×10^5; 1 ≤ y ≤ 10^9)가 주어집니다 — 상품의 개수와 가격표 하나를 인쇄하는 비용입니다.

두 번째 줄에는 n개의 정수 c1, c2, ..., cn (1 ≤ ci ≤ 2×10^5)이 주어집니다 — 상품들의 초기 가격입니다.

## 출력

각 테스트 케이스에 대해, 최대 총 수익을 나타내는 하나의 정수를 출력하세요.

## 예제

**입력:**
```
4
5 51
50 150 50 148 150
3 1000000000
42 42 42
10 54321
1 8088 45 1 73 1 9198 4991 1 83
3 100
1 1 1
```

**출력:**
```
31
-2999999937
-162755
3
```

## 설명

첫 번째 테스트 케이스에서는 x=3을 선택하는 것이 최적입니다. 상품들의 새로운 가격은 [17, 50, 17, 50, 50]이 됩니다. 이 경우, 50짜리 기존 가격표 2개를 사용할 수 있고, 17, 17, 50에 대해 3개의 가격표를 인쇄해야 합니다. 결과적으로 수익은 17+50+17+50+50-51×3=31이 됩니다.

두 번째 테스트 케이스에서는 x=2를 선택하는 것이 최적입니다. 새로운 가격은 [21, 21, 21]이 되고, 3개의 새 가격표를 인쇄해야 합니다.

세 번째 테스트 케이스에서는 x=111을 선택하는 것이 최적입니다.

네 번째 테스트 케이스에서는 x=2를 선택하는 것이 최적입니다. 새로운 가격은 기존 가격과 동일하므로, 새 가격표를 인쇄할 필요가 없습니다.