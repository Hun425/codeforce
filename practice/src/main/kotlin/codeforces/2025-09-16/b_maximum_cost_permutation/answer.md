# B. Maximum Cost Permutation - 풀이 해설

## 문제 분석

이 문제는 주어진 배열에서 0을 적절한 숫자로 채워 순열을 만들고, 그 순열의 **최대 비용(cost)**을 구하는 문제입니다.

여기서 **비용**은 전체 배열을 오름차순으로 정렬하기 위해 정렬해야 하는 연속적인 부분 배열의 최소 길이입니다.

## 핵심 아이디어

1. **비용의 정의 이해**:
   - 비용 = 전체 길이 - 정렬된 접두사 길이 - 정렬된 접미사 길이
   - 이미 정렬된 왼쪽 접두사와 오른쪽 접미사는 정렬할 필요가 없습니다.

2. **최대 비용을 위한 전략**:
   - 정렬된 접두사와 접미사를 **최소화**해야 합니다.
   - 0 위치에서 **전략적으로 선택**하여 정렬 구간을 방해해야 합니다.

## 알고리즘 설계

### 1단계: 누락된 숫자 찾기
```kotlin
val missing = mutableSetOf<Int>()
for (i in 1..n) {
    missing.add(i)
}
for (i in 0 until n) {
    if (p[i] > 0) {
        missing.remove(p[i])
    }
}
```

### 2단계: 왼쪽 접두사 최소 길이 계산
```kotlin
var minLeftPrefix = 0
for (i in 0 until n) {
    if (p[i] == i + 1) {
        // 이미 올바른 위치에 있음
        minLeftPrefix++
    } else if (p[i] == 0) {
        val neededValue = i + 1
        if (missing.contains(neededValue) && missing.size > 1) {
            // 다른 선택지가 있으므로 접두사를 끊을 수 있음
            break
        } else if (missing.contains(neededValue)) {
            // 어쩔 수 없이 연장
            minLeftPrefix++
            missing.remove(neededValue)
        } else {
            break
        }
    } else {
        break
    }
}
```

### 3단계: 오른쪽 접미사 최소 길이 계산
비슷한 방식으로 오른쪽에서부터 접미사 길이를 계산합니다.

### 4단계: 최대 비용 계산
```kotlin
return n - minLeftPrefix - minRightSuffix
```

## 핵심 통찰

**0 위치에서의 선택 전략:**
- **선택권이 있는 경우**: 정렬을 방해하는 숫자 선택 (접두사/접미사 중단)
- **선택권이 없는 경우**: 어쩔 수 없이 올바른 숫자 선택 (접두사/접미사 연장)

## 예제 분석

### 예제 1: [1, 0, 4, 0, 5]
- 누락된 숫자: {2, 3}
- 왼쪽 접두사: [1] (길이 1) - 두 번째 위치에서 2대신 3 선택하여 중단 가능
- 오른쪽 접미사: [5] (길이 1) - 고정
- 비용: 5 - 1 - 1 = 3

### 예제 2: [0, 0, 0]
- 누락된 숫자: {1, 2, 3}
- 왼쪽 접두사: 첫 번째 위치에서 1 대신 다른 숫자 선택 가능 (길이 0)
- 오른쪽 접미사: 마지막 위치에서 3 대신 다른 숫자 선택 가능 (길이 0)
- 비용: 3 - 0 - 0 = 3

### 예제 3: [1, 2, 3, 0]
- 누락된 숫자: {4}
- 왼쪽 접두사: [1, 2, 3] (길이 3) - 고정
- 마지막 위치: 4밖에 선택지 없음 → 전체 정렬
- 비용: 0

### 예제 4: [0, 3, 2]
- 누락된 숫자: {1}
- 첫 번째 위치: 1밖에 선택지 없음 → [1, 3, 2]
- 왼쪽 접두사: [1] (길이 1)
- 오른쪽 접미사: 없음 (길이 0)
- 비용: 3 - 1 - 0 = 2

## 시간 복잡도 및 공간 복잡도

- **시간 복잡도**: O(n) - 선형 시간으로 효율적
- **공간 복잡도**: O(n) - 누락된 숫자 저장용

## 핵심 포인트

1. **수학적 접근**: 비용 공식을 활용한 직접 계산
2. **전략적 배치**: 선택권이 있을 때만 정렬 방해
3. **효율성**: 브루트포스 대신 O(n) 알고리즘으로 해결

이 알고리즘은 0의 전략적 배치를 통해 최대 비용을 효율적으로 계산합니다.