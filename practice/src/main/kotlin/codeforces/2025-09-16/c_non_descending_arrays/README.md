# C. Non-Descending Arrays

## 문제 설명

길이 $n$인 두 정수 배열 $a$와 $b$가 주어진다.

인덱스들의 임의의 부분집합을 선택하여 해당 위치의 원소들을 교환할 수 있다 (즉, 부분집합의 각 인덱스 $i$에 대해 `swap(ai, bi)`를 수행). 인덱스 부분집합이 **좋다(good)**고 하는 것은, 교환 후에 두 배열이 모두 비내림차순으로 정렬되는 경우이다.

좋은 부분집합의 개수를 구하는 것이 당신의 임무이다. 답이 클 수 있으므로 998244353으로 나눈 나머지를 출력한다.

## 입력

첫 번째 줄에는 테스트 케이스의 수 $t$ (1 ≤ t ≤ 500)가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 정수 $n$ (1 ≤ n ≤ 100)이 주어진다.

두 번째 줄에는 $n$개의 정수 $a_1, a_2, …, a_n$ (1 ≤ a_i ≤ 1000)이 주어진다.

세 번째 줄에는 $n$개의 정수 $b_1, b_2, …, b_n$ (1 ≤ b_i ≤ 1000)이 주어진다.

추가 제약 조건: 적어도 하나의 좋은 부분집합이 존재한다.

## 출력

각 테스트 케이스에 대해, 좋은 부분집합의 개수를 998244353으로 나눈 나머지를 출력한다.

## 예제

### 입력
```
3
3
2 1 4
1 3 2
1
4
4
5
2 3 3 4 4
1 1 3 5 6
```

### 출력
```
2
2
8
```

## 예제 설명

첫 번째 예제에서, 2개의 좋은 부분집합이 있다: {1, 3}과 {2}.

두 번째 예제에서, 2개의 좋은 부분집합이 있다: {1}과 {} (공집합).

세 번째 예제에서, 8개의 좋은 부분집합이 있다: {1, 2, 3, 4, 5}, {1, 2, 3}, {1, 2, 4, 5}, {1, 2}, {3, 4, 5}, {3}, {4, 5} 그리고 {} (공집합).