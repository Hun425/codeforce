# B. Discounts - 풀이 해설

## 문제 분석

이 문제는 할인 바우처를 최적으로 사용하여 모든 상품을 구매하는 최소 비용을 구하는 그리디 알고리즘 문제입니다.

### 핵심 메커니즘
- 값 `x`의 바우처: `x`개 상품을 선택하여 **가장 비싼 (x-1)개만 결제**, **가장 저렴한 1개는 무료**
- 각 상품은 최대 1개의 할인 그룹에만 포함 가능
- 목표: 전체 구매 비용 최소화

## 핵심 아이디어

**무료가 되는 상품의 가치를 최대화**하는 것이 핵심입니다!

### 전략 비교

**잘못된 접근: 큰 바우처부터 사용**
```
상품: [18, 9, 7, 3, 2], 바우처: [1, 1, 3]
1. b=3: [18,9,7] → 7 무료 → 절약 7
2. b=1: [3] → 3 무료 → 절약 3
3. b=1: [2] → 2 무료 → 절약 2
총 절약: 12 → 비용: 27
```

**올바른 접근: 작은 바우처부터 사용**
```
1. b=1: [18] → 18 무료 → 절약 18
2. b=1: [9] → 9 무료 → 절약 9
3. b=3: [7,3,2] → 2 무료 → 절약 2
총 절약: 29 → 비용: 10 ✓
```

### 왜 작은 바우처부터가 최적인가?

1. **b=1 바우처의 특수성**: 선택한 상품 그 자체가 무료가 됨
2. **가치 최대화**: 작은 바우처로 가장 비싼 상품들을 무료로 만들고, 큰 바우처로 남은 저렴한 상품들을 정리
3. **그리디 선택**: 각 단계에서 가장 큰 절약 효과를 얻을 수 있는 선택

## 알고리즘 설계

1. **상품 가격을 내림차순으로 정렬** (비싼 상품부터 처리)
2. **바우처를 오름차순으로 정렬** (작은 바우처부터 사용)
3. **바우처 순차 적용**:
   - `b=1`: 현재 포인터의 상품을 무료로 처리
   - `b>1`: 현재 포인터부터 `b`개 상품 그룹에서 가장 저렴한 상품을 무료로 처리
4. **사용된 상품만큼 포인터 이동**

## 구현

```kotlin
fun solve(n: Int, k: Int, a: LongArray, b: IntArray): Long {
    a.sortDescending()  // 상품을 비싼 순으로 정렬
    b.sort()           // 바우처를 작은 순으로 정렬

    var totalCost = a.sum()
    var productPtr = 0

    // 바우처를 작은 것부터 사용 (최적 전략)
    for (voucherSize in b) {
        if (productPtr + voucherSize <= n) {
            if (voucherSize == 1) {
                // b=1: 해당 상품 무료
                totalCost -= a[productPtr]
            } else {
                // b>1: 그룹에서 가장 저렴한 상품 무료
                totalCost -= a[productPtr + voucherSize - 1]
            }
            productPtr += voucherSize
        }
    }

    return totalCost
}
```

## 시간 복잡도

- **정렬**: O(n log n + k log k)
- **바우처 처리**: O(k)
- **전체**: **O(n log n + k log k)**

## 공간 복잡도

- **O(1)** (입력 배열 외 추가 공간 사용 없음)

## 테스트 케이스 검증

### 테스트 케이스 1
```
입력: n=5, a=[18,3,7,2,9], b=[3,1,1]
정렬: a=[18,9,7,3,2], b=[1,1,3]

1. b=1: [18] → 18무료 → 절약18
2. b=1: [9] → 9무료 → 절약9
3. b=3: [7,3,2] → 2무료 → 절약2

총비용: 39-(18+9+2) = 10 ✓
```

### 테스트 케이스 5
```
입력: n=5, a=[99,99,999,999,123], b=[2,1,4]
정렬: a=[999,999,123,99,99], b=[1,2,4]

1. b=1: [999] → 999무료 → 절약999
2. b=2: [999,123] → 123무료 → 절약123
3. b=4: 남은상품 2개뿐 → 사용불가

총비용: 2319-(999+123) = 1197 ✓
```

## 핵심 포인트

1. **그리디 전략**: 작은 바우처부터 사용하여 비싼 상품들을 우선적으로 무료화
2. **정렬의 중요성**: 상품은 내림차순, 바우처는 오름차순
3. **경계 조건**: 바우처 크기가 남은 상품 수를 초과하지 않도록 검사
4. **효율성**: 단순한 반복문으로 O(n log n) 시간에 해결