# A. All Lengths Subtraction

- **시간 제한**: 테스트 케이스당 1초
- **메모리 제한**: 테스트 케이스당 256메가바이트

## 문제 설명

길이가 `n`인 순열 `p`가 주어집니다.

당신은 `k=1`부터 `n`까지의 각 정수에 대해 순서대로 정확히 한 번의 연산을 수행해야 합니다:

- `p`의 부분 배열 중 길이가 정확히 `k`인 것을 하나 선택하고, 그 부분 배열의 모든 원소에서 1을 뺍니다.

모든 `n`개의 연산을 완료한 후, 배열의 모든 원소가 0이 되도록 하는 것이 목표입니다.

이것이 가능한지 판별하세요.

- **순열(permutation)**: 길이가 `n`인 순열은 `1`부터 `n`까지의 서로 다른 정수가 임의의 순서로 배열된 것입니다. 예를 들어, `[2,3,1,5,4]`는 순열이지만, `[1,2,2]` (2가 두 번 나타남)나 `[1,3,4]` (n=3인데 4가 있음)는 순열이 아닙니다.
- **부분 배열(subarray)**: 배열 `a`가 배열 `b`의 부분 배열이라는 것은, `b`의 처음에서 몇 개(0개 포함)의 원소를 제거하고 끝에서 몇 개(0개 포함)의 원소를 제거하여 `a`를 얻을 수 있다는 의미입니다.

## 입력

- 각 테스트는 여러 테스트 케이스를 포함합니다. 첫 번째 줄에는 테스트 케이스의 수 `t` (1 ≤ t ≤ 100)가 주어집니다.
- 각 테스트 케이스의 첫 번째 줄에는 순열의 길이 `n` (1 ≤ n ≤ 100)이 주어집니다.
- 두 번째 줄에는 순열 `p1, p2, ..., pn` (1 ≤ pi ≤ n)이 주어집니다.

## 출력

- 각 테스트 케이스에 대해, 모든 배열 원소를 0으로 만드는 것이 가능하면 "YES"를, 그렇지 않으면 "NO"를 출력합니다.
- 답은 대소문자를 구분하지 않습니다. ("yEs", "yes", "Yes", "YES" 등 모두 정답으로 인정됩니다.)

## 예제

**입력:**
```
4
4
1 3 4 2
5
1 5 2 4 3
5
2 4 5 3 1
3
3 1 2
```

**출력:**
```
YES
NO
YES
NO
```
