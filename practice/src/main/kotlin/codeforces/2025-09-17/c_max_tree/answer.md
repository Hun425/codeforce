## C. Max Tree 문제 풀이 해설

### 1. 문제 분석

이 문제는 주어진 트리와 각 간선에 연결된 두 가중치 `x`, `y`를 사용하여, 모든 간선의 기여도 합이 최대가 되는 순열 `p`를 찾는 것입니다.

간선 `(u, v)` (단, `u < v`)의 기여도는 다음과 같이 결정됩니다.
- `p[u] > p[v]` 이면 `x`
- `p[u] <= p[v]` 이면 `y`

전체 순열의 값은 모든 간선의 기여도를 합한 값이므로, 각 간선에서 `x`와 `y` 중 더 큰 값을 선택해야 총합을 최대화할 수 있습니다.

### 2. 핵심 아이디어

각 간선에서 기여도를 최대로 만들기 위한 조건을 생각해보면 다음과 같은 의존 관계를 도출할 수 있습니다.

- **만약 `x > y` 라면:**
  - 기여도로 `x`를 선택해야 합니다.
  - 이를 위해서는 `p[u] > p[v]` 조건을 만족해야 합니다.
  - 이는 순열 값을 할당할 때, `v`가 `u`보다 작은 값을 가져야 함을 의미합니다.

- **만약 `y >= x` 라면:**
  - 기여도로 `y`를 선택해야 합니다.
  - 이를 위해서는 `p[v] > p[u]` 조건을 만족해야 합니다.
  - 이는 순열 값을 할당할 때, `u`가 `v`보다 작은 값을 가져야 함을 의미합니다.

이러한 의존 관계는 방향 그래프로 모델링할 수 있습니다. 예를 들어, `p[a]`가 `p[b]`보다 작아야 한다는 제약은 `a -> b` 라는 방향성 간선으로 표현할 수 있습니다. 즉, `a`가 `b`보다 먼저 처리되어야 한다는 의미입니다.

문제에서 주어진 그래프는 트리이므로, 위와 같이 생성된 의존성 그래프는 항상 **방향 비순환 그래프(DAG)**가 됩니다. 따라서, 모든 의존성을 만족하는 정점의 처리 순서를 찾기 위해 **위상 정렬(Topological Sort)**을 사용할 수 있습니다.

### 3. 알고리즘 설계

1.  **의존성 그래프 생성**:
    - `n`개의 정점을 준비합니다.
    - `n-1`개의 각 간선 `(u, v, x, y)`에 대해:
        - `x > y` 이면, `v -> u` 간선을 추가합니다. (`v`가 `u`보다 먼저 와야 함)
        - `y >= x` 이면, `u -> v` 간선을 추가합니다. (`u`가 `v`보다 먼저 와야 함)
    - 이 과정에서 각 정점의 진입 차수(in-degree)를 계산합니다.

2.  **위상 정렬 수행 (칸 알고리즘)**:
    - 진입 차수가 0인 모든 정점을 큐에 넣습니다.
    - 큐가 빌 때까지 다음을 반복합니다:
        - 큐에서 정점 `curr`를 꺼내 위상 정렬 결과 리스트에 추가합니다.
        - `curr`에서 나가는 모든 간선 `(curr -> next)`에 대해:
            - `next`의 진입 차수를 1 감소시킵니다.
            - 만약 `next`의 진입 차수가 0이 되면, 큐에 추가합니다.

3.  **순열 값 할당**:
    - 위상 정렬된 순서대로 정점들이 `topoOrder` 리스트에 저장됩니다. 이 순서는 모든 `a -> b` 의존성에 대해 `a`가 `b`보다 먼저 나타나는 것을 보장합니다.
    - `topoOrder`의 `i`번째 정점(`topoOrder[i]`)에 순열 값으로 `i + 1`을 할당합니다. 이렇게 하면 `a`가 `b`보다 먼저 나올 경우 `p[a] < p[b]`가 되어 모든 제약 조건을 만족시킬 수 있습니다.

4.  **결과 출력**:
    - 최종적으로 계산된 순열 `p`를 출력합니다.

### 4. 시간 복잡도 분석

- **그래프 생성**: `n-1`개의 간선을 한 번씩 순회하므로 `O(n)`입니다.
- **위상 정렬**: 칸 알고리즘은 모든 정점과 간선을 한 번씩 방문하므로 `O(V + E)`입니다. 여기서 `V`는 정점의 수(`n`), `E`는 의존성 그래프의 간선 수(`n-1`)이므로 `O(n)`입니다.
- **순열 할당**: 위상 정렬된 결과를 순회하며 값을 할당하므로 `O(n)`입니다.

따라서, 각 테스트 케이스에 대한 총 시간 복잡도는 **`O(n)`**입니다.

### 5. 예제 시각화 (예제 1 기준)

예제 1의 입력은 다음과 같습니다.
- `n = 3`
- 간선 1: `u=1, v=2, x=2, y=1`
- 간선 2: `u=2, v=3, x=3, y=2`

#### 단계 1: 의존성 관계 분석

- **간선 1 (1, 2)**: `x=2`, `y=1` 입니다. `x > y` 이므로, 기여도 `x=2`를 얻기 위해 `p[1] > p[2]`여야 합니다. 이는 `p[2]`가 `p[1]`보다 작은 값을 가져야 함을 의미합니다.
- **간선 2 (2, 3)**: `x=3`, `y=2` 입니다. `x > y` 이므로, 기여도 `x=3`을 얻기 위해 `p[2] > p[3]`여야 합니다. 이는 `p[3]`이 `p[2]`보다 작은 값을 가져야 함을 의미합니다.

정리하면, 순열 값은 `p[3] < p[2] < p[1]` 관계를 만족해야 합니다.

#### 단계 2: 의존성 그래프 생성

`p[a] < p[b]` 관계를 `a -> b` 방향 간선으로 표현하여 의존성 그래프를 만듭니다. 이는 "`a`를 처리해야 `b`를 처리할 수 있다"는 의미입니다.

- `p[3] < p[2]`  =>  `3 -> 2`
- `p[2] < p[1]`  =>  `2 -> 1`

이 의존성을 시각화하면 다음과 같은 간단한 방향 그래프가 됩니다.

```
(3) --> (2) --> (1)
```

- 정점 3의 진입 차수(in-degree) = 0
- 정점 2의 진입 차수(in-degree) = 1 (3으로부터)
- 정점 1의 진입 차수(in-degree) = 1 (2로부터)

#### 단계 3: 위상 정렬

1.  진입 차수가 0인 정점 `3`을 큐에 넣습니다. `queue = [3]`
2.  큐에서 `3`을 꺼내고, 결과 리스트에 추가합니다. `topoOrder = [3]`
3.  `3`과 연결된 정점 `2`의 진입 차수를 1 감소시킵니다. `2`의 진입 차수는 0이 되므로 큐에 넣습니다. `queue = [2]`
4.  큐에서 `2`를 꺼내고, 결과 리스트에 추가합니다. `topoOrder = [3, 2]`
5.  `2`와 연결된 정점 `1`의 진입 차수를 1 감소시킵니다. `1`의 진입 차수는 0이 되므로 큐에 넣습니다. `queue = [1]`
6.  큐에서 `1`을 꺼내고, 결과 리스트에 추가합니다. `topoOrder = [3, 2, 1]`

최종 위상 정렬 순서는 `[3, 2, 1]` 입니다.

#### 단계 4: 순열 할당

위상 정렬 순서대로 정점에 1부터 오름차순으로 값을 할당합니다.

- `topoOrder`의 첫 번째 정점 `3`에는 값 `1`을 할당: `p[3] = 1`
- `topoOrder`의 두 번째 정점 `2`에는 값 `2`를 할당: `p[2] = 2`
- `topoOrder`의 세 번째 정점 `1`에는 값 `3`을 할당: `p[1] = 3`

따라서 최종 순열 `p`는 `[p[1], p[2], p[3]]` 즉, `[3, 2, 1]`이 됩니다. 이는 예제 출력과 일치합니다.
