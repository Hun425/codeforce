# C. Wrong Binary Search

**시간 제한:** 2초\
**메모리 제한:** 256MB

정수 `n`과 길이가 `n`인 **이진 문자열** `s`가 주어진다.

길이 `n`의 **순열** `p`와 정수 `x`에 대해, `find(x)`를 다음 의사코드로
정의한다.

``` pseudo
function find(int x):
    l := 1
    r := n
    while l <= r:
        let m be a random integer between l and r (inclusive)
        if p[m] == x
            return m
        if p[m] > x:
            r := m - 1
        else:
            l := m + 1
    return undefined     // not found
```

우리는 정수 `x (1 ≤ x ≤ n)`가 다음 조건을 만족할 때 **stable**하다고
부른다.

-   `find(x)`가 항상 `undefined`가 아니어야 한다.
-   그리고 `p[find(x)] = x`가 **항상** 성립해야 한다.
-   (즉, 위 알고리즘에서 어떤 `m`이 선택되더라도 결과가 항상 올바른
    인덱스를 반환해야 한다.)

당신은 길이 `n`의 순열 `p`를 구성해야 한다. 조건은 다음과 같다.

-   `1 ≤ i ≤ n`에 대해, 정수 `i`가 **stable**일 때 **당且 그때만**
    `s[i] = 1`이어야 한다.

만약 그러한 순열이 존재하지 않는다면, "NO"를 출력해야 한다.

------------------------------------------------------------------------

### 정의

-   **이진 문자열:** 각 문자가 `0` 또는 `1`인 문자열.
-   **순열:** 1부터 n까지의 서로 다른 정수를 한 번씩 포함하는 배열.\
    예를 들어 `[2,3,1,5,4]`는 순열이지만 `[1,2,2]`는 (2가 중복되므로)
    순열이 아니며, `[1,3,4]`도 (4가 범위를 벗어남) 순열이 아니다.

------------------------------------------------------------------------

### 입력

여러 테스트 케이스가 주어진다.\
첫 줄에는 테스트 케이스의 수 `t (1 ≤ t ≤ 10^4)`가 주어진다.

각 테스트 케이스에 대해:

-   첫 줄에는 정수 `n (2 ≤ n ≤ 2⋅10^5)` --- 순열의 길이가 주어진다.
-   두 번째 줄에는 길이 `n`의 이진 문자열 `s`가 주어진다.

모든 테스트 케이스에 대해 `n`의 합은 `2⋅10^5`를 넘지 않는다.

------------------------------------------------------------------------

### 출력

각 테스트 케이스에 대해:

-   가능한 순열이 없으면 "NO"를 출력한다.
-   가능한 순열이 있으면 "YES"를 출력한 뒤, 다음 줄에 길이 `n`의 순열
    `p1 p2 … pn`을 출력한다.

여러 답이 가능하면 아무거나 출력해도 된다.

------------------------------------------------------------------------

### 예제 입력

    6
    3
    111
    5
    00000
    5
    10100
    7
    0010000
    11
    00001001100
    12
    011100010000

### 예제 출력

    YES
    1 2 3 
    YES
    2 4 3 5 1
    NO
    YES
    2 1 3 5 7 6 4
    YES
    2 1 4 3 5 7 6 8 9 11 10
    NO

------------------------------------------------------------------------

### 설명

#### 첫 번째 테스트 케이스

우리가 구성한 순열은 `p = [1,2,3]`이다.\
예를 들어 `find(2)`의 동작은 다음과 같다.

-   처음에 `l=1`, `r=3`이다.
-   `m`을 `1 ≤ m ≤ 3` 사이에서 무작위로 선택한다.
-   만약 `m=1`이면 `p1=1<2`이므로 `l=m+1=2`가 된다.\
    이제 `l=2`, `r=3`.
-   다시 `m`을 2와 3 사이에서 고른다.
  -   `m=2`이면 `p2=2`이므로 2를 반환한다.
  -   `m=3`이면 `p3=3>2`이므로 `r=m-1=2`. 이제 `l=2`, `r=2`, `m=2`가
      강제 선택된다.\
      결국 항상 2를 반환한다.

즉, 어떤 `m`을 고르더라도 결과는 항상 `2`이고, `p[find(2)] = p2 = 2`가
성립하므로 `2`는 stable하다.

같은 방식으로 `1`, `3`도 stable임을 확인할 수 있다.

#### 두 번째 테스트 케이스

우리가 구성한 순열은 `p = [2,4,3,5,1]`이다.

-   예를 들어 `find(3)`을 실행하면,\
    결국 `l > r`가 되어 `undefined`를 반환한다.

즉, 3은 stable하지 않다. (그리고 1, 2, 4, 5도 stable하지 않음)

따라서 이 순열은 조건을 만족한다.

다른 정답 예시로 `p = [5,4,3,2,1]` 또는 `p=[3,5,1,4,2]`도 가능하다.

#### 세 번째 테스트 케이스

조건을 만족하는 순열이 존재하지 않음을 증명할 수 있다.
