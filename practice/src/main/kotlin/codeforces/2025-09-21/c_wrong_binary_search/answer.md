# 🧩 C. 잘못된 이진 탐색 

## ✨ 핵심 아이디어

> `find(x)`는 **적대적 선택**도 가능한 이진 탐색이다.\
> 즉, 어떤 m이 선택되어도 `x`가 반드시 찾아져야 한다.

이 조건은 매우 강하다. x를 **항상** 찾으려면 다음이 성립해야 한다:

-   모든 **왼쪽 인덱스 m \< pos(x)** → p\[m\] \< x
-   모든 **오른쪽 인덱스 m \> pos(x)** → p\[m\] \> x

왜냐하면, 만약 왼쪽에 x보다 큰 값이 있으면, 어떤 m을 골랐을 때 r이 m-1로
줄어 **x의 진짜 위치를 버려버릴 수 있기 때문**이다.\
오른쪽에도 마찬가지로, x보다 작은 값이 있으면 l이 m+1로 증가해 **x를
건너뛸 수 있다**.

📌 **결론:**\
이 조건을 만족하는 유일한 위치는 **고정점**이다.\
즉, 안정적이려면 **반드시 `p[x] = x`** 여야 한다.

------------------------------------------------------------------------

## 📏 조건 정리 (필요충분 조건)

> **필요조건:**\
> - pos(x) 왼쪽에 있는 값들은 모두 x보다 작아야 함\
> - pos(x) 오른쪽에 있는 값들은 모두 x보다 커야 함\
> - 따라서 pos(x)=x로 강제됨

> **충분조건:**\
> 위 조건이 성립하면 어떤 m을 선택해도 pos(x)가 남아 있으므로 언젠가
> m=pos(x)를 선택하게 되고 x를 찾음.\
> 따라서 안정성 보장.

이 말은 **안정적인 인덱스가 있으면 그것이 배열을 경계로 나눈다**는
뜻이다.\
그 경계 사이(연속된 0 구간)는 해당 구간 값들만 재배치할 수 있으며,
고정점이 없어야 한다.

------------------------------------------------------------------------

## 🛠️ 순열 구성 (Construction)

1.  **고정점 배치:**\
    모든 s\[i\]=1인 인덱스에 대해 p\[i\]=i로 둔다.

2.  **0 구간 처리:**\
    s\[i\]=0인 부분을 최대 연속 구간 \[L..R\]으로 분할한다.\
    각 구간에 대해서:

    -   구간에 속한 값 집합은 정확히 {L, L+1, ..., R}

    -   이 집합을 **원형 시프트**하여 배치

        ``` text
        [L, L+1, ..., R-1, R] → [L+1, L+2, ..., R, L]
        ```

        이렇게 하면 구간 내 고정점이 사라진다.

3.  **불가능한 경우:**

    -   길이가 1인 구간이 있다면 어떤 방식으로도 p\[i\] ≠ i로 만들 수
        없다.
    -   즉, 이 경우에는 답이 존재하지 않는다.

------------------------------------------------------------------------

## 🧠 정확성 증명 (스케치)

1.  (**필요성 증명**)\
    안정적이라면 어떤 m을 골라도 pos(x)가 범위 안에 남아야 한다.\
    왼쪽에 x보다 큰 값이 있으면 r이 줄어 pos(x)를 잃어버리고, 오른쪽에
    x보다 작은 값이 있으면 l이 커져 pos(x)를 잃는다.\
    따라서 pos(x)의 왼쪽은 전부 \<x, 오른쪽은 전부 \>x.\
    즉 pos(x)=x로 강제된다.

2.  (**충분성 증명**)\
    이렇게 만들어진 p에서, pos(x)의 왼쪽은 전부 \<x, 오른쪽은 전부
    \>x이므로 어떤 m을 골라도 다음 탐색 범위는 pos(x)를 포함한다.\
    결국 언젠가 pos(x)가 선택되고 x를 반환한다.

3.  (**0 구간 처리**)\
    원형 시프트로 인해 어떤 값 x도 pos(x)=x가 아니며, 반드시 x보다 큰
    값이 왼쪽이나 작은 값이 오른쪽에 존재한다.\
    따라서 안정성이 깨지고, s\[i\]=0 조건을 만족한다.

4.  길이 1 구간은 고정점이 강제되므로 불가능.

------------------------------------------------------------------------

## ⚡ 알고리즘 절차

1.  문자열을 왼쪽부터 훑음
2.  s\[i\]=1 → p\[i\]=i
3.  s\[i\]=0 → 최대 연속 구간 \[i..j-1\] 찾기
    -   길이=1 → 즉시 "NO"
    -   길이≥2 → 구간 내 원형 시프트
4.  최종 p 출력

복잡도: O(n) → 모든 테스트 케이스 합 2×10⁵에서 안전.

------------------------------------------------------------------------

## 🧪 코너 케이스 정리

s         결과   설명
  --------- ------ -------------------------
`10`      YES    p=\[1,2\]
`01`      NO     길이 1 구간 불가
`00000`   YES    p=\[2,3,4,5,1\] 등
`10100`   NO     중간에 길이 1 구간 있음

------------------------------------------------------------------------

## ✅ 예시 검증

### 예제 1 --- 가능

``` text
s = 00000
연속 구간 [1..5] → 원형 시프트
p = [2,3,4,5,1]   # 또는 [3,4,5,1,2] 등도 정답
```

### 예제 2 --- 불가능

``` text
s = 10100
구간 [3] → 길이 1 → 불가능 → NO
```

------------------------------------------------------------------------

💡 **정리:**\
- 안정적이면 무조건 고정점 p\[x\]=x - 0 구간은 원형 시프트로 배치해
  고정점 제거 - 길이 1 구간이 있으면 "NO"
