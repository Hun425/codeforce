# A. 동일한 등장 횟수 — 풀이 해설 (Kotlin)

## 문제 요약

* 비내림차순 배열 `a(길이 n)`가 주어질 때, **모든 값의 등장 횟수가 같은** 서브시퀀스 중 **최대 길이**를 구하는 문제.
* 빈 배열은 항상 균형(balanced)으로 간주.
* 값의 범위는 `1..n`, `n ≤ 100`.

## 핵심 아이디어

어떤 정수 `K (≥1)`를 정하고, 등장 빈도 `f[v]`가 `K` 이상인 서로 다른 값들을 골라 **각 값에서 정확히 `K`개씩** 뽑으면 길이는 `K * cnt_K`가 됩니다.
여기서 `cnt_K = #{ v | f[v] ≥ K }` 입니다.

따라서 정답은 아래 최댓값입니다.

$$
\max_{K \in [1, \max f]} \; K \cdot \#\{v \mid f[v] \ge K\}
$$

왜냐하면 균형 조건상 **선택된 모든 값이 같은 개수 `K`만큼** 뽑혀야 하기 때문입니다.

## 정당성 (왜 맞는가)

* 균형 잡힌 서브시퀀스에서는 모든 값의 선택 개수가 동일해야 하므로, 어떤 공통 개수 `K`가 존재합니다.
* 특정 `K`에 대해 쓸 수 있는 값은 `f[v] ≥ K`인 값들뿐입니다. 각 값에서 `K`개씩 뽑아 총 길이 `K * cnt_K`를 만들 수 있습니다.
* 가능한 모든 `K`에 대해 위 값을 계산해 최댓값을 취하면 최적입니다.

## 알고리즘

1. `freq[x]`에 각 값의 등장 횟수를 센다.
2. `maxF = max(freq)`를 구한다.
3. 빈도별 값의 개수 배열 `cntByFreq[f] = 빈도가 f인 값의 가짓수`를 만든다.
4. 큰 `K`에서 작은 `K`로 내려가며, 누적 개수 `atLeast`에 `cntByFreq[K]`를 더해 `f ≥ K`인 값의 수를 유지한다.
5. 매 `K`마다 후보 길이 `K * atLeast`를 계산, 최댓값 갱신.
6. 최댓값 반환.

* 시간복잡도: `O(n + maxF)` (n ≤ 100, 충분히 작음)
* 공간복잡도: `O(n)`

## 예시로 검증

* `a = [1,1,4,4,4]`

    * `freq: 1→2, 4→3`, `maxF = 3`
    * `K=3`: `atLeast=1`(값4만 가능) → 후보 `3*1=3`
    * `K=2`: `atLeast=2`(값1,4) → 후보 `2*2=4` ← 최댓값
    * 정답 `4` (예: `[1,1,4,4]`)
* `a = [1,2]`

    * `freq: 1→1, 2→1`, `maxF=1`
    * `K=1`: `atLeast=2` → `1*2=2`, 정답 `2`.

## 자주 하는 실수 / 주의

* **연속 부분 배열**이 아니라 **서브시퀀스**입니다. 인접할 필요가 없습니다.
* 값의 범위가 `1..n`으로 주어지므로 `freq` 크기는 `n+1`이면 충분합니다.
* 빈 배열(혹은 선택을 0개 하는 경우)도 균형이지만, 문제는 **최대 길이**를 묻습니다. (필요하면 `0`과 비교)

## 확장 아이디어

* `n`이 커지면 `K` 순회 시 `atLeast` 누적 기법(위 구현처럼)을 쓰면 `O(n + maxF)`로 효율적입니다.
* 값의 범위가 큰 일반 케이스에서는 `HashMap`으로 `freq`를 만들고, `freq` 값들만 모아 정렬/카운팅하는 방식으로 확장 가능합니다.
